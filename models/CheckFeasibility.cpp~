#include <models/CheckFeasibility.hpp>

using namespace std;
using namespace Scan;
namespace Scan
{

CheckFeasibility::CheckFeasibility(): verbose(0)
{

}

CheckFeasibility::CheckFeasibility( int orderTask, int Alg,  vector<  TaskSet> tss,vector< pair<double,double> >p_d,vector<Processor> ps,int v)
    :task_sets(tss), processors(ps),verbose(v)
{
    output_file.open("Output.txt");
    for(int j=0; j<p_d.size(); j++)
    {
        period_deadline.push_back(p_d.at(j));
    }

    printProcessor(processors);
    switch ( orderTask )
    {
    case 0:
        order_task=orderTaskSelection::precedence;
        break;
    case 2:
        order_task=orderTaskSelection::increase_wcet;
        break;
    case 1:
        order_task=orderTaskSelection::decrease_wcet;
        break;
    default :
        order_task=orderTaskSelection::precedence;
    }

    switch ( Alg )
    {
    case 0:
    {
        proc_algorithm=precSelectionAlg::firstFit;
    }
    break;
    case 1:
    {
        proc_algorithm=precSelectionAlg::bestFit;

    }
    break;
    case 2:
    {
        proc_algorithm=precSelectionAlg::worstFit;
    }
    break;
    default :
    {
        proc_algorithm=precSelectionAlg::bestFit;
    }
    }
}


void CheckFeasibility::print_feasible_combination()
{
    cout<<endl;
    cout<<endl;
    cout<<"§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§§ "<<endl;
    output_file<<endl;
    output_file<<endl;
    cout<<endl;
    cout<<endl;
    output_file<<"---------- ------>>>>>>>>>>>  RISULTATO FINALE :: -------------"<<endl;
     cout<<"---------- ------>>>>>>>>>>>  RISULTATO FINALE :: -------------"<<endl;
    output_file<<endl;
    cout<<endl;
    cout<<endl;
    output_file<<endl;
    cout<<"size allocation :"<<feasible_all.size()<<endl;
    for(int i=0; i < feasible_all.size(); i++)
    {
        cout <<feasible_all.at(i);
        output_file<<feasible_all.at(i);
    }
}


void CheckFeasibility::check()
{
    int max_split;
    /** compute the maximum number of
    subsets in which tasks of each pipes can be
    grouped and asigned to processor.
    this value is minimum value between
    number of processor and max size of pipes **/
    int max_size= task_sets.at(0).size();
    for(int h=1; h<task_sets.size(); h++)
    {
        if(max_size< task_sets.at(h).size())
            max_size=task_sets.at(h).size();
    }
    max_split =max_size;
    if(max_size> processors.size())
        max_split=processors.size();
    /** we obtein all possible combinations
    express by arrays of intege */
    split(max_split,max_size);
    /**for(int i=0; i<task_sets.size(); i++)
    {**/
    if(verbose==1)
        cout<< "CHECK pipe di indice "<<0 <<endl;
    vector <Processor > proc;
    /** copy of processors **/
    for(int j=0; j<processors.size(); j++)
    {
        proc.push_back(processors.at(j));
    }
    /** split(max_split,max_size);**/
    vector<Procs_Allocation>first_feasible;
     check_feasibility_combinations(&proc, 0,max_split,first_feasible);
    print_feasible_combination();
    output_file.close();
}


int CheckFeasibility::select_Processor(vector<Processor> *proc, double bw)
{
    double free=0;
    bool used=false;
    switch(proc_algorithm)
    {
    case firstFit:
    {
        for(int i=0; i <proc->size(); i++)
        {
            free=proc->at(i).get_free();
            used=proc->at(i).get_flag_utilised();
            if(bw<=free)
            {
                if(verbose==1)
                    cout<<"bw :"<<bw<<" < "<< "free : "<<free <<endl;
                if(used==false)
                {
                    if(verbose==1)
                        cout <<" si ritorno il processore : " <<i<<endl;
                    proc->at(i).update(bw);
                    return i;
                }
            }
        }
    }
    break;
    case bestFit:
    {
        sort_proc<ProcCmpUtilizeIncr>(*proc);
        for(int i=0; i <proc->size(); i++)
        {
            free=proc->at(i).get_free();
            used=proc->at(i).get_flag_utilised();
            if(bw<=free)
            {
                if(verbose==1)
                    cout<<"bw :"<<bw<<" < "<< "free : "<<free <<endl;

                if(used==false)
                {
                    if(verbose==1)
                        cout <<" si ritorno il processore : " <<i<<endl;
                    proc->at(i).update(bw);
                    return i;
                }

            }
        }
    }
    break;
    case worstFit:
    {
        sort_proc<ProcCmpUtilizeDecr>(*proc);
        for(int i=0; i <proc->size(); i++)
        {
            free=proc->at(i).get_free();
            used=proc->at(i).get_flag_utilised();
            if(bw<=free)
            {
                if(verbose==1)
                    cout<<"bw :"<<bw<<" < "<< "free : "<<free <<endl;

                if(used==false)
                {
                    if(verbose==1)
                        cout <<" si ritorno il processore : " <<i<<endl;
                    proc->at(i).update(bw);
                    return i;
                }

            }
        }
    }
    break;
    }
    return -1;
}


void CheckFeasibility::printProcessor(vector< Processor>p)
{
    for(int i=0; i <p.size(); i++)
        cout <<p.at(i);
}


void CheckFeasibility::split( int max_split, int max_size_pipe)
{
    vector<int >p;
    vector <int> m;
    vector<int >* position=&p;
    vector <int> *max=&m;
    for(int j=0; j<max_size_pipe; j++)
    {
        position->push_back(1);
        max->push_back(1);
    }
    positions_combinations.push_back(*position);

    while(next(position,max,max_split ))
        {}
    /** stampa **/
    if(verbose==1)
    {
        for(int k=0; k< positions_combinations.size(); k++)
        {
            for(int h=0; h< positions_combinations.at(k).size(); h++)
                cout<<positions_combinations.at(k).at(h);
            cout<<endl;
            cout<<"----"<<endl;
        }
    }
}


template <class t>
void stampa_vettore(vector<t>v)
{
    for(int i=0; i<v.size(); i++)
        cout<<v.at(i);
    cout<<endl;
}

bool CheckFeasibility::next(vector<int> *position, vector<int>*max ,int size)
{
    int i=0;
    ++(position->at(i));
    bool not_insert= false;
    while(i< position->size()-1 && (position->at(i) > max->at(i+1)+1))
    {
        (*position)[i]=1;
        i++;
        ++position->at(i);

    }
    for(int h=0; h< position->size()&& not_insert==false; h++)
    {
        if(position->at(h)>size)
        {
            not_insert=true;
        }
    }
    if(i==position->size()-1)
    {
        return false;
    }
    if(position->at(i) > max->at(i))
    {
        (*max)[i]=(*position)[i];
    }
    for(int j=i-1; j>=0; j--)
    {
        (*max)[j]=(*max)[i];
    }
    if(position->at(0)<= size && not_insert==false )
    {
        positions_combinations.push_back(*position);
    }
    return true;
}

bool CheckFeasibility::is_last_combination(int index, int size, int max_split)
{
    int s= 1;
    /** check if combination at index "index" is last
    combinatio that have the structure increased, so
    for a pipe of 3 stage the last combination is 1 2 3:**/
    for(int i= size-1; i>=0 ; i--)
    {
        if(positions_combinations.at(index).at(i)!=s)
            return false;
        s++;
    }
    for(int j=size-max_split-1; j>0; j++)
    {
        if( positions_combinations.at(index).at(j)!=max_split)
            return false;
    }
    return true;
}

vector<int> CheckFeasibility::get_combination(int size_pipe,int index)
{
    vector <int> temp;
    for(int i =0; i <size_pipe; i++)
    {
        temp.push_back(positions_combinations.at(index).at(i));
        if(verbose==1)
            cout<<temp.at(i);
    }
    cout<<endl;
    return temp;
}


vector <Stage_Set> CheckFeasibility::get_Stage_Set(vector <int> position, int index_pipe)
{
    vector <Stage_Set> rss;
    for(int i=0; i< position.size(); i++)
    {
        if(rss.size() < position.at(i))
        {
            for(int j=rss.size(); j<position.at(i); j++)
            {
                Stage_Set *ts= new Stage_Set();
                rss.push_back(*ts);
            }
        }
        Task t=task_sets.at(index_pipe).at(i);
        Stage *r= new Stage(t,index_pipe,i);
        rss.at(position.at(i)-1)+=(*r);
    }
    if(verbose==1)
    {
        cout<<"Stage set che formano la combinazione :"<<rss.size()<<endl;
        for(int k=0; k<rss.size(); k++)
        {
            cout<<rss.at(k);
        }
    }
    return rss;
}


double CheckFeasibility::compute_partialBW(vector<Stage_Set>sets)
{
    double tot=0;
    vector <Stage_Set>t;
    for(int i=0; i < sets.size(); i++)
    {
        tot=tot+ (sets.at(i).get_bw_param()/sets.at(i).get_util());
    }
    return tot;
}

bool CheckFeasibility::check_feasibility_combinations( vector<Processor> *pro,int index_pipe,int max_split,vector<Procs_Allocation  >feasible_other_pipe)
{
    stampa_vettore(feasible_other_pipe);
    double sigma=0;
    double bw=0;
    double first= true;
    bool feasible=false;
    vector <Processor > proc;
    vector<Procs_Allocation>::iterator it;
    /** numero di stage della pipe considerata **/
    int stage_number= task_sets.at(index_pipe).size();
    int i=0;
    vector <int> combination=get_combination(stage_number, i);
    double deadline=period_deadline.at(index_pipe).second;
    while(is_last_combination(i,stage_number,max_split)!=true|| first==true)
    {
        /**faccio una copia dei processori**/
        for(int h=0; h<pro->size(); h++)
        {
            proc.push_back(pro->at(h));
            proc.at(proc.size()-1).set_flag_utilised(false);
        }
        /** Given a combinations, return tasks of pipe grouping
         according split combination**/
        vector<Stage_Set>sets_of_tasks=get_Stage_Set(combination,index_pipe);
        double parameter=compute_partialBW(sets_of_tasks);
        double sigma=1/deadline;
        sigma= sigma*parameter;
        switch ( order_task )
        {
        case increase_wcet:
        {
            sort_Stage_Sets<CmpWcetIncr>( sets_of_tasks) ;
        }
        break;
        case decrease_wcet:
        {
            sort_Stage_Sets<CmpWcetDecr>( sets_of_tasks);
        }
        }
        int index_proc=-1;
        feasible=true;
        vector <Procs_Allocation> one_feas_all;
        it= one_feas_all.begin();
        one_feas_all.insert(it, feasible_other_pipe.begin(),feasible_other_pipe.end());
        if(verbose==1)
        {
            for(int u=0; u<one_feas_all.size(); u++)
            {
                cout<<one_feas_all.at(u);
            }
        }
        if(first==false)
        {
            /**parametro per trovare la bw 1/D (sum sigma di i/Ui) ecc **/
            if(verbose==1)
            {
                output_file<<"Sigma :"<<sigma <<endl;
                cout <<"SIGMA   :"<<sigma<<endl;
            }
            /**Per tutti i sottoinsiemi di task ciascuno da assignare a un processore**/
            for(int k=0; k<sets_of_tasks.size()&&  feasible==true; k++)
            {
                bw=sets_of_tasks.at(k).get_util()*sigma;
                if(verbose==1)
                {
                    cout<<"NON E' LA PRIMA COMBINAZIONE"<<endl;
                    output_file<<"Bandwidth :"<<bw <<endl;
                    cout<<"BANDWIDT:  "<<bw<<endl;
                }
                //index_proc=select_Processor(&proc,sets_of_tasks.at(k),bw);
                index_proc=select_Processor(&proc,bw);
                if(index_proc!=-1)
                {
                    Processor p=proc.at(index_proc);
                    bool found=false;
                    for(int k=0; k< one_feas_all.size()&& found==false; k++)
                    {
                        if(one_feas_all.at(k).get_Processor().get_Id()==p.get_Id())
                        {
                            one_feas_all.at(k).update_task_allocated(p,index_pipe, sets_of_tasks.at(k));
                            found =true;
                        }
                    }
                    if(found!=true)
                    {
                        Procs_Allocation *one_feas= new Procs_Allocation(p,index_pipe, sets_of_tasks.at(k));
                        one_feas_all.push_back(*one_feas);
                    }
                }
                else
                {
                    feasible= false;
                    if(verbose==1)
                        output_file<<":-( COMBINAZIONE NON FEASIBLE "<<endl;
                }

            }
            if(feasible==true)
            {
                if(index_pipe== task_sets.size()-1)
                {
                    Feasible_Allcoation *pipes_allocated= new Feasible_Allcoation(one_feas_all);
                    if(verbose==1)
                    {
                        cout<<"§§§INSERISCO COMBINAZIONE PIPES FATTIBILE §§§"<<endl;
                        cout<<*pipes_allocated;
                        output_file<<*pipes_allocated;
                    }
                    feasible_all.push_back(*pipes_allocated);
                }
                /** chiamata ricorsiva sulle pipe rimanenti **/
                else
                {
                    cout<<"NON E' L'ULTIMA PIPE RICORRO"<<endl;
                    for(int u=0; u<one_feas_all.size(); u++)
                    {
                        cout<<one_feas_all.at(u);
                    }
                    check_feasibility_combinations(&proc, index_pipe +1, max_split, one_feas_all);
                }
            }
        }
        else
        {
            bw=sets_of_tasks.at(0).get_util();
            if(verbose==1)
            {
                output_file<<"BANDWIDT :  "<<bw<<endl;
                cout<<"BANDWIDT FIRST:  "<<bw<<endl;
            }
            //index_proc=select_Processor(&proc,sets_of_tasks.at(0),bw);
             index_proc=select_Processor(&proc,bw);
            if(index_proc!=-1)
            {
                Processor p=proc.at(index_proc);
                bool found=false;
                for(int k=0; k< one_feas_all.size()&& found==false; k++)
                {
                    if(one_feas_all.at(k).get_Processor().get_Id()==p.get_Id())
                    {
                        one_feas_all.at(k).update_task_allocated(p,index_pipe, sets_of_tasks.at(0));
                        found=true;
                    }
                }
                if(found!=true)
                {
                    Procs_Allocation *one_feas= new Procs_Allocation(p,index_pipe, sets_of_tasks.at(0));
                    one_feas_all.push_back(*one_feas);
                }
                if(index_pipe== task_sets.size()-1)
                {
                    Feasible_Allcoation *pipes_allocated= new Feasible_Allcoation(one_feas_all);
                    if(verbose==1)
                    {
                        cout<<"§§§INSERISCO COMBINAZIONE PIPES FATTIBILE §§§"<<endl;
                        cout<<*pipes_allocated;
                        output_file<<*pipes_allocated;
                    }
                    feasible_all.push_back(*pipes_allocated);
                }
                else     /** chiamata ricorsiva sulle pipe rimanenti **/
                {
                    if(verbose==1)
                    {
                        cout<<"NON E' L'ULTIMA PIPE RICORRO"<<endl;
                        for(int u=0; u<one_feas_all.size(); u++)
                        {
                            cout<<one_feas_all.at(u);
                        }
                    }
                    check_feasibility_combinations(&proc, index_pipe +1, max_split, one_feas_all);
                }
            }
            else
            {
                feasible= false;
            }
            first=false;
        }
        proc.clear();
        i++;
        combination=get_combination(stage_number, i);

    }
    if(feasible==false &&index_pipe<task_sets.size()-1)
        check_feasibility_combinations(pro, index_pipe +1, max_split, feasible_other_pipe);
}
}


/*void CheckFeasibility::map(vector<int> position, int index_pipe)
{
    vector <Stage_Set> tss;

    for(int i=0; i< position.size(); i++)
    {
        if(tss.size() < position.at(i))
            for(int j=tss.size(); j<position.at(i); j++)
            {
                Stage_Set *ts= new Stage_Set();
                tss.push_back(*ts);
            }
        Task t=task_sets.at(index_pipe).at(i);
        record *r= new record(t,index_pipe,i);
        tss.at(position.at(i)-1)+=(*r);


    }
    int k_level=tss.size();
    int s=(*all_combinations)[index_pipe].size();

    if(s< k_level)
    {
        for(int k=s; k<k_level; k++)
        {
            Level_Combinations * lc = new Level_Combinations();
            (*all_combinations)[index_pipe].push_back(*lc);
        }

    }

    (*all_combinations)[index_pipe][k_level-1].insert(tss,position);


}*/
